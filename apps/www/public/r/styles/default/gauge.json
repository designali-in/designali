{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "gauge",
  "type": "registry:ui",
  "author": "shadcn (https://ui.shadcn.com)",
  "files": [
    {
      "path": "ui/gauge.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport type { CSSProperties, SVGProps } from \"react\";\n\nexport interface GaugeProps extends Omit<SVGProps<SVGSVGElement>, \"className\"> {\n  value: number;\n  size?: number | string;\n  gapPercent?: number;\n  strokeWidth?: number;\n  equal?: boolean;\n  showValue?: boolean;\n\n  primary?:\n    | \"danger\"\n    | \"warning\"\n    | \"success\"\n    | \"info\"\n    | string\n    | { [key: number]: string };\n  secondary?:\n    | \"danger\"\n    | \"warning\"\n    | \"success\"\n    | \"info\"\n    | string\n    | { [key: number]: string };\n\n  transition?: {\n    length?: number;\n    step?: number;\n    delay?: number;\n  };\n\n  className?:\n    | string\n    | {\n        svgClassName?: string;\n        primaryClassName?: string;\n        secondaryClassName?: string;\n        textClassName?: string;\n      };\n}\n\n/**\n * Renders a circular gauge using SVG. Allows configuration of colors, stroke, and animations.\n * @param value - Current value of the gauge, expressed as a percentage.\n * @param size = Width and height of the gauge. Defaults to 100%.\n * @param gapPercent -  Percentage of the total circumference that represents a gap in the gauge. Defaults to 5%.\n * @param strokeWidth - Stroke width of the gauge. Defaults to 10px.\n * @param equal - Determines if the gauge should have equal primary and secondary stroke lengths. Defaults to false.\n * @param showValue - Option to display the numeric value inside the gauge. Defaults to true.\n * @param primary - Primary color or set of colors for the gauge, with optional threshold values to determine color changes.\n * @param secondary - Secondary color or set of colors for the gauge, similar to `primary`.\n * @param transition - Transition settings for the gauge's animation, specifying the length, step, and delay of transitions.\n * @param className - Class names for different parts of the gauge, including the SVG container and individual elements.\n * @param props Configuration and properties for the svg.\n */\nexport function Gauge({\n  value,\n  size = \"100%\",\n  gapPercent = 5,\n  strokeWidth = 10,\n  equal = false,\n  showValue = true,\n\n  primary,\n  secondary,\n\n  transition = {\n    length: 1000, // ms\n    step: 200, // ms\n    delay: 0, // ms\n  },\n\n  className,\n\n  ...props\n}: GaugeProps) {\n  const strokePercent = value; // %\n\n  const circleSize = 100; // px\n  const radius = circleSize / 2 - strokeWidth / 2;\n  const circumference = 2 * Math.PI * radius;\n\n  const percentToDegree = 360 / 100; // deg\n  const percentToPx = circumference / 100; // px\n\n  const offsetFactor = equal ? 0.5 : 0;\n  const offsetFactorSecondary = 1 - offsetFactor;\n\n  const primaryStrokeDasharray = () => {\n    if (\n      offsetFactor > 0 &&\n      strokePercent > 100 - gapPercent * 2 * offsetFactor\n    ) {\n      // calculation to gradually shift back to 0 offset as progress nears 100% when offsetFactor > 0\n      const subtract = -strokePercent + 100;\n\n      return `${Math.max(strokePercent * percentToPx - subtract * percentToPx, 0)} ${circumference}`;\n    } else {\n      const subtract = gapPercent * 2 * offsetFactor;\n\n      return `${Math.max(strokePercent * percentToPx - subtract * percentToPx, 0)} ${circumference}`;\n    }\n  };\n\n  const secondaryStrokeDasharray = () => {\n    if (\n      offsetFactorSecondary < 1 &&\n      strokePercent < gapPercent * 2 * offsetFactorSecondary\n    ) {\n      // calculation to gradually shift back to 1 secondary offset as progress nears 100% when offsetFactorSecondary < 1\n      const subtract = strokePercent;\n\n      return `${Math.max((100 - strokePercent) * percentToPx - subtract * percentToPx, 0)} ${circumference}`;\n    } else {\n      const subtract = gapPercent * 2 * offsetFactorSecondary;\n\n      return `${Math.max((100 - strokePercent) * percentToPx - subtract * percentToPx, 0)} ${circumference}`;\n    }\n  };\n\n  const primaryTransform = () => {\n    if (\n      offsetFactor > 0 &&\n      strokePercent > 100 - gapPercent * 2 * offsetFactor\n    ) {\n      // calculation to gradually shift back to 0 offset as progress nears 100% when offsetFactor > 0\n      const add = 0.5 * (-strokePercent + 100);\n\n      return `rotate(${-90 + add * percentToDegree}deg)`;\n    } else {\n      const add = gapPercent * offsetFactor;\n\n      return `rotate(${-90 + add * percentToDegree}deg)`;\n    }\n  };\n\n  const secondaryTransform = () => {\n    if (\n      offsetFactorSecondary < 1 &&\n      strokePercent < gapPercent * 2 * offsetFactorSecondary\n    ) {\n      // calculation to gradually shift back to 1 secondary offset as progress nears 100% when offsetFactorSecondary < 1\n      const subtract = 0.5 * strokePercent;\n\n      return `rotate(${360 - 90 - subtract * percentToDegree}deg) scaleY(-1)`;\n    } else {\n      const subtract = gapPercent * offsetFactorSecondary;\n\n      return `rotate(${360 - 90 - subtract * percentToDegree}deg) scaleY(-1)`;\n    }\n  };\n\n  const primaryStroke = () => {\n    if (!primary) {\n      return strokePercent <= 25\n        ? \"#dc2626\" // Red\n        : strokePercent <= 50\n          ? \"#f59e0b\" // Amber\n          : strokePercent <= 75\n            ? \"#3b82f6\" // Blue\n            : \"#22c55e\"; // Green\n    } else if (typeof primary === \"string\") {\n      return primary === \"danger\"\n        ? \"#dc2626\" // Red\n        : primary === \"warning\"\n          ? \"#f59e0b\" // Amber\n          : primary === \"info\"\n            ? \"#3b82f6\" // Blue\n            : primary === \"success\"\n              ? \"#22c55e\" // Green\n              : primary;\n    } else if (typeof primary === \"object\") {\n      const primaryKeys = Object.keys(primary).sort(\n        (a, b) => Number(a) - Number(b),\n      );\n      let primaryStroke = \"\";\n      for (let i = 0; i < primaryKeys.length; i++) {\n        const currentKey = Number(primaryKeys[i]);\n        const nextKey = Number(primaryKeys[i + 1]);\n\n        if (\n          strokePercent >= currentKey &&\n          (strokePercent < nextKey || !nextKey)\n        ) {\n          primaryStroke = primary[currentKey] || \"\";\n\n          if (\n            [\"danger\", \"warning\", \"success\", \"info\"].includes(primaryStroke)\n          ) {\n            primaryStroke =\n              {\n                danger: \"#dc2626\",\n                warning: \"#f59e0b\",\n                info: \"#3b82f6\",\n                success: \"#22c55e\",\n              }[primaryStroke] || primaryStroke;\n          }\n\n          break;\n        }\n      }\n      return primaryStroke;\n    }\n  };\n\n  const secondaryStroke = () => {\n    if (!secondary) {\n      return \"#9ca3af\"; // Default Gray\n    } else if (typeof secondary === \"string\") {\n      return secondary === \"danger\"\n        ? \"#fecaca\" // Light Red\n        : secondary === \"warning\"\n          ? \"#fde68a\" // Light Amber\n          : secondary === \"info\"\n            ? \"#bfdbfe\" // Light Blue\n            : secondary === \"success\"\n              ? \"#bbf7d0\" // Light Green\n              : secondary;\n    } else if (typeof secondary === \"object\") {\n      const stroke_percent_secondary = 100 - strokePercent;\n      const secondaryKeys = Object.keys(secondary).sort(\n        (a, b) => Number(a) - Number(b),\n      );\n      let secondaryStroke = \"\";\n\n      for (let i = 0; i < secondaryKeys.length; i++) {\n        const currentKey = Number(secondaryKeys[i]);\n        const nextKey = Number(secondaryKeys[i + 1]);\n\n        if (\n          stroke_percent_secondary >= currentKey &&\n          (stroke_percent_secondary < nextKey || !nextKey)\n        ) {\n          secondaryStroke = secondary[currentKey] || \"\";\n\n          if (\n            [\"danger\", \"warning\", \"success\", \"info\"].includes(secondaryStroke)\n          ) {\n            secondaryStroke =\n              {\n                danger: \"#fecaca\",\n                warning: \"#fde68a\",\n                info: \"#bfdbfe\",\n                success: \"#bbf7d0\",\n              }[secondaryStroke] || secondaryStroke;\n          }\n\n          break;\n        }\n      }\n      return secondaryStroke;\n    }\n  };\n\n  const primaryOpacity = () => {\n    if (\n      offsetFactor > 0 &&\n      strokePercent < gapPercent * 2 * offsetFactor &&\n      strokePercent < gapPercent * 2 * offsetFactorSecondary\n    ) {\n      return 0;\n    } else return 1;\n  };\n\n  const secondaryOpacity = () => {\n    if (\n      (offsetFactor === 0 && strokePercent > 100 - gapPercent * 2) ||\n      (offsetFactor > 0 &&\n        strokePercent > 100 - gapPercent * 2 * offsetFactor &&\n        strokePercent > 100 - gapPercent * 2 * offsetFactorSecondary)\n    ) {\n      return 0;\n    } else return 1;\n  };\n\n  const circleStyles: CSSProperties = {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    strokeDashoffset: 0,\n    strokeWidth: strokeWidth,\n    transition: `all ${transition?.length}ms ease ${transition?.delay}ms`,\n    transformOrigin: \"50% 50%\",\n    shapeRendering: \"geometricPrecision\",\n  };\n\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox={`0 0 ${circleSize} ${circleSize}`}\n      shapeRendering=\"crispEdges\"\n      width={size}\n      height={size}\n      style={{ userSelect: \"none\" }}\n      strokeWidth={2} // TODO: not needed?\n      fill=\"none\"\n      className={cn(\n        \"\",\n        typeof className === \"string\" ? className : className?.svgClassName,\n      )}\n      {...props}\n    >\n      {/*secondary*/}\n      <circle\n        cx={circleSize / 2}\n        cy={circleSize / 2}\n        r={radius}\n        style={{\n          ...circleStyles,\n          strokeDasharray: secondaryStrokeDasharray(),\n          transform: secondaryTransform(),\n          stroke: secondaryStroke(),\n          opacity: secondaryOpacity(),\n        }}\n        className={cn(\n          \"\",\n          typeof className === \"object\" && className?.secondaryClassName,\n        )}\n      />\n\n      {/* primary */}\n      <circle\n        cx={circleSize / 2}\n        cy={circleSize / 2}\n        r={radius}\n        style={{\n          ...circleStyles,\n          strokeDasharray: primaryStrokeDasharray(),\n          transform: primaryTransform(),\n          stroke: primaryStroke(),\n          opacity: primaryOpacity(),\n        }}\n        className={cn(\n          \"\",\n          typeof className === \"object\" && className?.primaryClassName,\n        )}\n      />\n\n      {showValue && (\n        <text\n          x=\"50%\"\n          y=\"50%\"\n          textAnchor=\"middle\"\n          dominantBaseline=\"middle\"\n          alignmentBaseline=\"central\"\n          fill=\"currentColor\"\n          fontSize={36}\n          className={cn(\n            \"font-semibold\",\n            typeof className === \"object\" && className?.textClassName,\n          )}\n        >\n          {Math.round(strokePercent)}\n        </text>\n      )}\n    </svg>\n  );\n}\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}